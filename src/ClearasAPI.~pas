{ *********************************************************************** }
{                                                                         }
{ Clearas API Interface Unit v4.1                                         }
{                                                                         }
{ Copyright (c) 2011-2013 P.Meisberger (PM Code Works)                    }
{                                                                         }
{ *********************************************************************** }

unit ClearasAPI;

interface

uses
  Windows, Classes, SysUtils, Registry, ShlObj, ActiveX, ComObj, CommCtrl,
  Contnrs, OSUtils;

const
  { Registry Keys }
  RECYCLEBIN_KEY = 'CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\shell';
  STARTUP_KEY = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Run';
  STARTUP_KEY64 = 'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Run';
  RUNONCE_KEY = 'SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce';
  DEACT_KEY = 'SOFTWARE\Microsoft\Shared Tools\MSConfig\startupreg\';
  DEACT_FOLDER = 'SOFTWARE\Microsoft\Shared Tools\MSConfig\startupfolder\';
  CONTEXTMENU_KEY = '\shellex\ContextMenuHandlers';

  { Extensions von Backup-Dateien }
  COMMON_EXT = '.CommonStartup';
  USER_EXT = '.Startup';

  REG_HEADER = 'Windows Registry Editor Version 5.00';
  COMMON_TYPE = 'Common Startup';
  USER_TYPE = 'Startup User';

type
  { Exception class }
  EClearasError = class(Exception);

  { Base class }
  TClearas = class(TOSUtils)
  protected
    class function AddPathDelimiter(APath: string): string;
    class function DeleteKey(AMainKey, AKeyPath, AKeyName: string): Boolean;
    class function DeleteValue(AMainKey, AKeyName, AValueName: string): Boolean;
  public
    class function CreateError(AMsgType, AContent, AName: string): Boolean;
    class function CreateLnk(const AExeFilename, ALinkFilename: string): Boolean;
    class function DeleteExt(AName: string): string;
    class function ExpandHKey(const ARootKey: string): string;
    class function GetKeyValue(AMainKey, AKeyPath, AValueName: string): string;
    class function GetStartUpDir(AAllUsers: Boolean): string;
    class function ReadLnkFile(const ALnkFileName: string; out APath: string): Boolean;
    class function RegisterInContextMenu(ACheck: Boolean): Boolean;
    class function UpdateContextPath: Boolean;
    class procedure WriteStrValue(AMainKey, AKeyName, AName, AValue: string);
  end;

  { Base List-Item }
  TRootItem = class(TClearas)
  private
    FIndex: Word;
	  FEnabled: Boolean;
    FName, FType: string;
    function MakeHeadLine(): string; virtual; abstract;
  protected
    function Disable(): Boolean; virtual; abstract;
    function Enable(): Boolean; virtual; abstract;
  public
    constructor Create(AIndex: Word; AEnabled: Boolean);
	  destructor Destroy; override;
	  function ChangeStatus(): Boolean; virtual;
    function Delete(): Boolean; virtual; abstract;
	  procedure ExportItem(const AFileName: string); virtual; abstract;
    procedure GetItemInfo(var AName, APath: string); virtual; abstract;
    function GetRegItem(ARegFile: TStrings): Boolean; virtual; abstract;
	  function GetStatus(): string;
    { external }
    property Enabled: Boolean read FEnabled;
    property ItemIndex: Word read FIndex;
    property Name: string read FName write FName;
    property TypeOf: string read FType write FType;
  end;

  { Base List }
  TRootList = class(TObjectList)
  private
    FActCount: Word;
  public
    constructor Create;
    destructor Destroy; override;
    function ChangeItemStatus(): Boolean; virtual; abstract;
    procedure Clear; override;
    function DeleteItem(): Boolean; virtual; abstract;
    { external }
    property ActCount: Word read FActCount;
  end;

  { Base StartupList-Item }
  TStartupListItem = class(TRootItem)
  private
    FRootKey, FFilePath, FKeyPath, FTime: string;
    function GetTime(): string;
    function MakeHeadLine(): string; override;
    function StartupUserType(): Boolean; virtual; abstract;
    procedure WriteTime(const AKeyPath: string);
  public
    function CreateBackup(): Boolean; virtual; abstract;
    function GetRegItem(ARegFile: TStrings): Boolean; override;
	  { external }
    property FilePath: string read FFilePath write FFilePath;
    property KeyPath: string read FKeyPath write FKeyPath;
    property RootKey: string read FRootKey write FRootKey;
    property StartupUser: Boolean read StartupUserType;
	  property Time: string read FTime write FTime;
  end;

  { Startup-Item }
  TStartupItem = class(TStartupListItem)
  private
    function StartupUserType(): Boolean; override;
  protected
    function Disable(): Boolean; override;
    function Enable(): Boolean; override;
  public
    function CreateBackup(): Boolean; override;
    function Delete(): Boolean; override;
    procedure ExportItem(const AFileName: string); override;
    procedure GetItemInfo(var AName, APath: string); override;
  end;

  { Startup User-Item }
  TStartupUserItem = class(TStartupListItem)
  private
    function AddCircumflex(const AName: string): string;
    function GetBackupLnk(): string;
    function GetExtension(): string;
    function StartupUserType(): Boolean; override;
  protected
    function Disable(): Boolean; override;
    function Enable(): Boolean; override;
  public
    function CreateBackup(): Boolean; override;
    function Delete(): Boolean; override;
    procedure ExportItem(const AFileName: string); override;
    procedure GetItemInfo(var AName, APath: string); override;
  end;

  { Startup-List }
  TStartupList = class(TRootList)
  private
    FActAppIndex: PInt;
    FItem: TStartupListItem;
    FDeleteBackup: Boolean;
    function Add(AItem: TStartupListItem): Word; virtual;
    function DelCircumflex(AName: string): string;
    function DeleteBackupLnk(): Boolean;
    function GetBackupLnk(): string;
    function GetItem(AIndex: Word): TStartupListItem;
    procedure GetLnkFileNames(AFileList: TStrings; AAllUsers: Boolean);
    function GetStartupUserType(const AKeyPath: string): string;
  protected
    function AddItemDisabled(const AKeyPath: string): Integer;
    function AddItemEnabled(const ARootKey, AKeyPath, AName, AFilePath: string): Integer;
    function AddUserItemDisabled(const AKeyPath: string): Integer;
    function AddUserItemEnabled(const ALnkFile: string; AAllUsers: Boolean): Integer;
  public
    constructor Create;
    function CreateBackup(): Boolean;
    procedure AddDisabled(const AKeyPath: string);
    procedure AddEnabled(const AAllUsers: Boolean); overload;
    procedure AddEnabled(const ARootKey, AKeyPath: string); overload;
    function BackupExists(): Boolean;
    procedure ExportItem(const AFileName: string; ARegFile: Boolean = true);
    procedure ExportList(const AFileName: string);
    function ChangeItemStatus(): Boolean; override;
    function DeleteItem(): Boolean; override;
    function IndexOf(AName: string): Integer; overload;
    function IndexOf(AName: string; AEnabled: Boolean): Integer; overload;
    procedure Insert(AIndex: Integer; AItem: TStartupListItem);
    procedure Load(ARunOnce: Boolean);
    { external }
    property AppIndex: PInt read FActAppIndex write FActAppIndex;
    property DeleteBackup: Boolean read FDeleteBackup write FDeleteBackup;
    property Items[AIndex: Word]: TStartupListItem read GetItem; default;
    property Item: TStartupListItem read FItem write FItem;
  end;

  { Base-ContextListItem }
  TContextListItem = class(TRootItem)
  private
    FLocation: string;
    function GetKeyPath(): string; virtual; abstract;
    function MakeHeadLine(): string; override;
  public
    function Delete(): Boolean; override;
	  procedure ExportItem(const AFileName: string); override;
    procedure GetItemInfo(var AName, APath: string); override;
    function GetRegItem(ARegFile: TStrings): Boolean; override;
    { external }
    property KeyPath: string read GetKeyPath;
    property Location: string read FLocation;
  end;

  { Shell-Item }
  TShellItem = class(TContextListItem)
  private
    function GetKeyPath(): string; override;
  protected
    function Disable(): Boolean; override;
    function Enable(): Boolean; override;
  end;

  { ShellEx-Item }
  TShellExItem = class(TContextListItem)
  private
    function GetKeyPath(): string; override;
  protected
    function Disable(): Boolean; override;
    function Enable(): Boolean; override;
  end;

  { Search Events }
  TOnSearchBeginEvent = procedure(Sender: TObject; AWorkCountMax: Integer) of object;
  TOnSearchEvent = procedure(Sender: TObject; AWorkCount: Integer) of object;
  TOnSearchEndEvent = procedure(Sender: TObject) of object;

  { Context-List }
  TContextList = class(TRootList)
  private
    FItem: TContextListItem;
    FCountMax, FProgress: Integer;
    FWorkCount: TOnSearchEvent;
    FWorkCountMax: TOnSearchBeginEvent;
    FContextCount: TOnSearchEndEvent;
    function Add(AItem: TContextListItem): Word; virtual;
    function FindDouble(AName, AKeyName: string): Boolean;
    function GetItem(AIndex: Word): TContextListItem;
  protected
    function AddShellItem(const AName,  ALocation: string; AEnabled: Boolean): Word;
    function AddShellExItem(const AName, ALocation: string; AEnabled: Boolean): Word;
    procedure AddEntry(const AKeyName: string; AShell: Boolean); overload;
  public
    constructor Create;
    procedure AddEntry(); overload;
    procedure AddEntry(const AKeyName: string); overload;
    function ChangeItemStatus(): Boolean; override;
    function DeleteItem(): Boolean; override;
    procedure ExportItem(const AFileName: string);
    function IndexOf(AName: string): Integer; overload;
    function IndexOf(AName, ALocation: string): Integer; overload;
    procedure Insert(AIndex: Integer; AItem: TContextListItem); virtual;
    procedure Load;
    { external }
    property Items[AIndex: Word]: TContextListItem read GetItem; default;
    property Item: TContextListItem read FItem write FItem;
    property OnSearch: TOnSearchEvent read FWorkCount write FWorkCount;
    property OnSearchBegin: TOnSearchBeginEvent read FWorkCountMax write FWorkCountMax;
    property OnSearchEnd: TOnSearchEndEvent read FContextCount write FContextCount;
  end;

implementation

uses ClearasMain;

{ private }
class function TClearas.AddPathDelimiter(APath: string): string;   //2.Backslash einfügen
var
  fullpath: string;

begin
  if (APath <> '') then
     if (APath[1] = '"') then
        begin
        fullpath := StringReplace(APath, '\', '\\', [rfReplaceAll]);
        APath := StringReplace(fullpath, '"', '\"', [rfReplaceAll]);
        result := '"'+ APath +'"';
        end  //of begin
     else
        result := StringReplace('"'+ APath +'"', '\', '\\', [rfReplaceAll])
  else
     result := '""';
end;


class function TClearas.DeleteKey(AMainKey, AKeyPath, AKeyName: string): Boolean;
var
  reg: TRegistry;

begin
  reg := TRegistry.Create(SetKeyAccessMode);      //init von reg mit setzen der Rechte

  try
    reg.RootKey := StrToHKey(AMainKey);           //HKEY öffnen
    reg.OpenKey(AKeyPath, false);                 //SubKey öffnen
    result := reg.DeleteKey(AKeyName);            //Key löschen und ggf. Fehlererkennung

  finally                                         //freigeben
    reg.Free;
  end;  //of finally
end;


class function TClearas.DeleteValue(AMainKey, AKeyName, AValueName: string): Boolean;
var
  reg: TRegistry;

begin
  reg := TRegistry.Create(SetKeyAccessMode);      //init von reg mit setzen der Rechte

  try
    reg.RootKey := StrToHKey(AMainKey);           //HKEY öffnen
    reg.OpenKey(AKeyName, false);                 //SubKey öffnen
    result := reg.DeleteValue(AValueName);        //Wert löschen

  finally                                         //freigeben
    reg.Free;
  end;  //of finally
end;

{ public }
class function TClearas.CreateError(AMsgType, AContent, AName: string): Boolean;
begin
  if (AName <> '') then
     raise EClearasError.Create(AMsgType + Main.Lang.GetString(66) +^J+^J+ Main.Lang.GetString(67)
                             + AContent +^J+'('+ AName +')')
  else
     raise EClearasError.Create(AMsgType + Main.Lang.GetString(66) +^J+^J + Main.Lang.GetString(67)
                             + AContent);   
  result := false;
end;

class function TClearas.CreateLnk(const AExeFilename, ALinkFilename: string): Boolean;
var
  shellLink : IShellLink;
  persistFile : IPersistFile;
  name : PWideChar;

begin
  result := false;

  if Succeeded(CoCreateInstance(CLSID_ShellLink, nil, CLSCTX_inPROC_SERVER,
               IID_IShellLinkA, shellLink)) then
     begin
     shellLink.SetPath(PChar(AExeFileName));                               //Pfad
     shellLink.SetWorkingDirectory(PChar(ExtractFilePath(AExeFileName)));  //Verzeichnis

     if Succeeded(shellLink.QueryInterface(IPersistFile, persistFile)) then
        begin
        GetMem(name, MAX_PATH*2);

          try
            MultiByteToWideChar(CP_ACP, 0, PChar(ALinkFilename), -1, name, MAX_PATH); //Speicherplatz reservieren
            persistFile.Save(name, true);     //*.lnk speichern
            result := true;

          finally
            FreeMem(name, MAX_PATH*2);
          end; //of finally
        end; //of begin
     end; //of begin
end;


class function TClearas.DeleteExt(AName: string): string;       //Endung löschen
var
  Index: Integer;
  Ext: string;

begin
  Ext := ExtractFileExt(AName);                   //Endung
  Index := Pos(Ext, AName);                       //Index der Endung

  if (Index <> 0) then                            //Endung gefunden?
     Delete(AName, Index, Index + Length(Ext)-1); //Endung löschen

  result := AName;
end;


class function TClearas.ExpandHKey(const ARootKey: string): string;
begin
  result := HKeyToStr(StrToHKey(ARootKey));
end;


class function TClearas.GetKeyValue(AMainKey, AKeyPath, AValueName: string): string;
var
  reg: TRegistry;

begin
  reg := TRegistry.Create(SetKeyAccessMode);    //init von reg mit setzen der Rechte

  try
    reg.RootKey := StrToHKey(AMainKey);         //HKEY öffnen

    if reg.OpenKey(AKeyPath, false) then        //SubKey öffnen
       begin
       if (reg.ValueExists(AValueName)) then    //existiert Wert?
          result := reg.ReadString(AValueName)  //...dann Wert auslesen
       else
          result := '';                         //sonst Fehler vermeiden
       end  //of begin
    else
       result := '';

  finally                                       //freigeben
    reg.Free;
  end; //of finally
end;


class function TClearas.GetStartUpDir(AAllUsers: Boolean): string; //Autostart Dir ermitteln
var
  pidl: PItemIDList;
  path: PChar;
  folder: Cardinal;

begin
  if AAllUsers then
     folder := CSIDL_COMMON_STARTUP
  else
     folder := CSIDL_STARTUP;

  if Succeeded(SHGetSpecialFolderLocation(0, folder, pidl)) then  //Autostart Dir
     begin
     path := StrAlloc(max_path);
     SHGetPathFromIDList(pidl, path);
     result := string(path);

     if (result[length(result)] <> '\') then
        result := result +'\';
     end;  //of begin
end;


class function TClearas.ReadLnkFile(const ALnkFileName: string; out APath: string): Boolean;
var
  ShellLink: IShellLink;
  PersistFile: IPersistFile;
  FileInfo: TWin32FindData;

begin
  result := false;

  if Succeeded(CoCreateInstance(CLSID_ShellLink, nil, CLSCTX_INPROC_SERVER,
     IShellLink, ShellLink)) then
     begin
     PersistFile := ShellLink as IPersistFile;

     if Succeeded(PersistFile.Load(StringToOleStr(ALnkFileName), STGM_READ)) then
        with ShellLink do
          begin
          SetLength(APath, MAX_PATH + 1);

          if Succeeded(GetPath(PChar(APath), MAX_PATH, FileInfo, SLR_ANY_MATCH)) then
             begin
             APath := PChar(APath);
             result := true;
             end;  //of begin
          end; //of with
     end;  //of begin
end;


class function TClearas.RegisterInContextMenu(ACheck: Boolean): Boolean;  //in Kontextmenü eintragen/austragen
var
  reg: TRegistry;

begin
  reg := TRegistry.Create(SetKeyAccessMode);                //init reg
  reg.RootKey := HKEY_CLASSES_ROOT;                         //Root Key festlegen
  reg.OpenKey(RECYCLEBIN_KEY, false);                       //SubKey festlegen

  if not ACheck then
     begin
       try
         with reg do
           begin
           CreateKey( Main.Lang.GetString(71));
           CloseKey;
           OpenKey(RECYCLEBIN_KEY +'\'+  Main.Lang.GetString(71), True);
           CreateKey('command');
           CloseKey;
           OpenKey(RECYCLEBIN_KEY +  Main.Lang.GetString(72), True);
           WriteString('', ParamStr(0));
           CloseKey;
           end;  //of with

         result := true;

       except
         result := false;
       end;  //of try
     end  //of begin
  else
     begin
       try
         reg.DeleteKey( Main.Lang.GetString(71));
         reg.CloseKey;
         result := false;

       except
         result := true;
       end;  //of try
     end;  //of if

  reg.Free;
end;


class function TClearas.UpdateContextPath(): Boolean;
var
  reg: TRegistry;

begin
  reg := TRegistry.Create(SetKeyAccessMode);
  reg.RootKey := HKEY_CLASSES_ROOT;

  try
    reg.OpenKey(RECYCLEBIN_KEY, false);

    if (reg.KeyExists( Main.Lang.GetString(71))) then  //Falls Kontextmenü-Eintrag
    begin                                    //existiert
      reg.CloseKey;
      reg.OpenKey(RECYCLEBIN_KEY +  Main.Lang.GetString(72), false);
      reg.WriteString('', ParamStr(0));        //aktuellen Pfad speichern
      result := true;
    end  //of begin
    else
       result := false;

  finally                                       //freigeben
    reg.Free;
  end;  //of finally
end;


class procedure TClearas.WriteStrValue(AMainKey, AKeyName, AName, AValue: string);
var
  reg: TRegistry;

begin
  reg := TRegistry.Create(SetKeyAccessMode);      //init von reg mit setzen der Rechte

  try
    reg.RootKey := StrToHKey(AMainKey);         //HKEY öffnen
    reg.OpenKey(AKeyName, true);                //SubKey öffnen
    reg.WriteString(AName, AValue);             //Name + Wert übernehmen

  finally                                       //freigeben
    reg.Free;
  end; //of finally
end;
{ of TClearas }

{##############################################################################}
{ TRootItem }

constructor TRootItem.Create(AIndex: Word; AEnabled: Boolean);
begin
  inherited Create;
  FIndex := AIndex;
  FEnabled := AEnabled;
end;


destructor TRootItem.Destroy;
begin
  inherited Destroy;
end;

{ public }
function TRootItem.ChangeStatus: Boolean;
begin
  if FEnabled then
     result := Disable
  else
     result := Enable;
end;


function TRootItem.GetStatus(): string;
begin
  if FEnabled then
    result := Main.Lang.GetString(31)
  else
    result :=  Main.Lang.GetString(32);
end;
{ of TRootItem }

{##############################################################################}
{ TRootList }

constructor TRootList.Create;
begin
  inherited Create;
  FActCount := 0;
end;


destructor TRootList.Destroy;
begin
  inherited Destroy;
end;

{ public }
procedure TRootList.Clear;
begin
  inherited Clear;
  FActCount := 0;
end;
{ of TRootList }

{##############################################################################}
{ TStartupListItem }

function TStartupListItem.GetTime(): string;  //Zeitpunkt der Deaktivierung auslesen
var
  reg: TRegistry;
  Year, Month, Day, Hour, Min, Sec: Word;
  Date, Time: string;

begin
  reg := TRegistry.Create(SetKeyAccessMode);             //init reg-Object

  try
    if not FEnabled then
       begin
       reg.RootKey := StrToHKey(FRootKey);               //HKEY öffnen
       reg.OpenKey(FKeyPath, false);                     //SubKey öffnen

       if not reg.ValueExists('YEAR') then               //Wert existiert?
          result := '00.00.0000 00:00:00'
       else
          begin
          Year := reg.ReadInteger('YEAR');               //auslesen...
          Month := reg.ReadInteger('MONTH');
          Day := reg.ReadInteger('DAY');
          Hour := reg.ReadInteger('HOUR');
          Min := reg.ReadInteger('MINUTE');
          Sec := reg.ReadInteger('SECOND');
          Date := FormatDateTime('c', EncodeDate(Year, Month, Day));
          Time := FormatDateTime('tt', EncodeTime(Hour, Min, Sec, 0));
          result := Date +'  '+ Time;
          end;  //of if
       end;  //of if

  finally                                                //freigeben
    reg.Free;
  end;  //of finally
end;


function TStartupListItem.MakeHeadLine(): string;
begin
  result := '['+ HKeyToStr(StrToHKey(FRootKey)) +'\'+ FKeyPath +']';
end;


procedure TStartupListItem.WriteTime(const AKeyPath: string);  //Zeitpunkt der Deaktivierung speichern
var
  reg: TRegistry;
  Year, Month, Day, Hour, Min, Sec, MSec: Word;
  TimeNow: TDateTime;

begin
  reg := TRegistry.Create(SetKeyAccessMode);      //init REG-Object
  reg.RootKey := HKEY_LOCAL_MACHINE;              //HKEY öffnen

  try
    reg.OpenKey(AKeyPath, true);                  //SubKey öffnen
    TimeNow := Now();
    FTime := FormatDateTime('c', TimeNow);        //Deaktivierungsdatum
    DecodeDate(TimeNow, Year, Month, Day);        //Datum auslesen
    DecodeTime(TimeNow, Hour, Min, Sec, MSec);    //Zeit auslesen

    with reg do
      begin                                       //Deaktivierungsdatum speichern
      WriteInteger('YEAR', Year);
      WriteInteger('MONTH', Month);
      WriteInteger('DAY', Day);
      WriteInteger('HOUR', Hour);
      WriteInteger('MINUTE', Min);
      WriteInteger('SECOND', Sec);
      end;  //of with

  finally                                         //freigeben
    reg.Free;
  end;  //of finally
end;

{ public }
function TStartupListItem.GetRegItem(ARegFile: TStrings): Boolean;
var
  reg: TRegistry;
  List: TStringList;
  i: Word;

begin
  reg := TRegistry.Create(SetKeyAccessMode);          //init reg Objekt

  try
    reg.RootKey := StrToHKey(FRootKey);               //RootKey setzen
    reg.OpenKey(FKeyPath, false);                     //RegKey öffnen
    result := true;

  except
    reg.Free;
    result := false;
    Exit;                                             //bei Fehlern abbrechen!
  end;  //of try

  try
    List := TStringList.Create;                       //init Liste
    reg.GetValueNames(List);                          //alle Werte im Schlüssel auslesen

    with ARegFile do
      if not FEnabled then                            //deaktivierte Einträge
         for i := 0 to List.Count -1 do
           case reg.GetDataType(List[i]) of
             rdString : ARegFile.Append('"'+ List[i] +'"='+ TClearas.AddPathDelimiter(reg.ReadString(List[i])));
             rdInteger: ARegFile.Append('"'+ List[i] +'"=dword:'+ IntToHex(reg.ReadInteger(List[i]), 8));
           end  //of case
      else                                            //aktivierte Einträge
         Append('"'+ FName +'"='+ TClearas.AddPathDelimiter(FFilePath));

  finally
    reg.Free;
  end;  //of try
end;
{ of TStartupListItem }

{##############################################################################}
{ TStartupItem }

function TStartupItem.StartupUserType(): Boolean;
begin
  result := false;
end;

{ protected }
function TStartupItem.Disable(): Boolean;
var
  reg: TRegistry;

begin
  reg := TRegistry.Create(SetKeyAccessMode);          //init REG-Zugriff

  try
    reg.RootKey := HKEY_LOCAL_MACHINE;                //RootKey setzen

    if (DeleteValue(FRootKey, FKeyPath, FName) and    //Autostarteintrag gelöscht und
       reg.OpenKey(DEACT_KEY + FName, true)) then     //neuer Schlüssel erstellt?
       begin
       reg.WriteString('hkey', FRootKey);             //Werte schreiben...
       reg.WriteString('key', FKeyPath);
       reg.WriteString('item', FName);
       reg.WriteString('command', FFilePath);
       reg.WriteString('inimapping', '0');

       if CheckWindows then                           //nur ab Windows Vista:
          WriteTime(DEACT_KEY + FName);               //Deaktivierungsdatum speichern

       FRootKey := 'HKLM';                            //Daten aktualisieren
       FKeyPath := DEACT_KEY + FName;
       FEnabled := false;                             //Status aktualisieren
       result := true;
       end  //of begin
    else
       result := CreateError(Main.Lang.GetString(64), Main.Lang.GetString(78), '');  //Fehlererkennung

  except
    result := false;
  end; //of try

  reg.Free;                                      //Objekt freigeben
end;


function TStartupItem.Enable(): Boolean;
var
  reg: TRegistry;
  NewHKey, NewKeyPath: string;

begin
  reg := TRegistry.Create(SetKeyAccessMode);      //init REG-Object

  try
    reg.RootKey := HKEY_LOCAL_MACHINE;
    reg.OpenKey(FKeyPath, false);                 //alten Schlüssel öffnen
    NewHKey := reg.ReadString('hkey');            //neuer HKEY auslesen
    NewKeyPath := reg.ReadString('key');          //neuer Pfad auslesen
    reg.CloseKey;

    if ((NewHKey = '') or (NewKeyPath = '')) then //Fehlererkennung
       result := CreateError(Main.Lang.GetString(63), Main.Lang.GetString(74), '')
    else
       begin
       reg.RootKey := StrToHKey(NewHKey);

       if reg.OpenKey(NewKeyPath, true) then
          begin
          reg.WriteString(FName, FFilePath);      //Autostarteintrag schreiben
          result := DeleteKey('HKLM', DEACT_KEY, FName);  //alten Schlüssel löschen

          FRootKey := NewHKey;                    //Daten aktualisieren
          FKeyPath := NewKeyPath;
          FEnabled := true;                       //Status aktualisieren
          FTime := '';
          end  //of begin
       else
          result := CreateError(Main.Lang.GetString(63), Main.Lang.GetString(78), FFilePath);  //Fehlererkennung
       end;  //of if

  except
    result := false;
  end;  //of try

  reg.Free;                                       //freigeben
end;

{ public }
function TStartupItem.CreateBackup(): Boolean;
begin
  result := true;
end;


function TStartupItem.Delete(): Boolean;
begin
  result := true;

  try
    if FEnabled then
       begin
       if not DeleteValue(FRootKey, FKeyPath, FName) then
          result := CreateError(Main.Lang.GetString(65), Main.Lang.GetString(75), FName);
       end  //of begin
    else
       if not DeleteKey('HKLM', DEACT_KEY, FName) then
          result := CreateError(Main.Lang.GetString(65), Main.Lang.GetString(77), FName);

  except
    result := false;
  end;  //of try
end;


procedure TStartupItem.ExportItem(const AFileName: string);
var
  RegFile: TStringList;

begin
  RegFile := TStringList.Create;                  //init Liste/Datei

  try
    RegFile.Append(REG_HEADER);                   //*.reg Header
    RegFile.Append('');
    RegFile.Append(MakeHeadLine());               //REG SChlüssel
    GetRegItem(RegFile);                          //Daten in Liste schreiben
    RegFile.SaveToFile(AFileName {+'.reg'});      //*.REG erstellen

  finally
    RegFile.Free;                                 //freigeben
  end;  //of try
end;


procedure TStartupItem.GetItemInfo(var AName, APath: string);
begin
  APath := Main.Lang.GetString(61) +^J+^J+ ExpandHKey(FRootKey) +'\'+ FKeyPath;
  AName := Main.Lang.GetString(62) +'"'+ FName +'"';
end;
{ of TStartupItem }

{##############################################################################}
{ TStartupUserItem }

function TStartupUserItem.AddCircumflex(const AName: string): string;
begin
  result := StringReplace(AName, '\', '^', [rfReplaceAll]);
end;


function TStartupUserItem.GetBackupLnk(): string;
begin
  result := GetWinDir +'\pss\'+ FName + GetExtension();
end;


function TStartupUserItem.GetExtension(): string;
begin
  if (Pos('Common', FType) <> 0) then
     result := COMMON_EXT
  else
     result := USER_EXT;
end;


function TStartupUserItem.StartupUserType(): Boolean;
begin
  result := true;
end;

{ protected }
function TStartupUserItem.Disable(): Boolean;
var
  reg: TRegistry;
  Path, KeyName, PssDir, BackupLnk: string;

begin
  reg := TRegistry.Create(SetKeyAccessMode);            //init REG-Zugriff

  try
    reg.RootKey := HKEY_LOCAL_MACHINE;                  //RootKey setzen
    KeyName := AddCircumflex(FKeyPath);
    PssDir := GetWinDir +'\pss';
    BackupLnk := GetBackupLnk();

    if (reg.OpenKey(DEACT_FOLDER + KeyName, true) and
       ReadLnkFile(FKeyPath, Path)) then
       begin                                            //Daten schreiben
       reg.WriteString('path', FKeyPath);
       reg.WriteString('item', DeleteExt(ExtractFileName(FName)));
       reg.WriteString('command', FFilePath);
       reg.WriteString('backup', BackupLnk);

       if CheckWindows then                             //nur ab Windows Vista
          begin
          reg.WriteString('backupExtension', GetExtension());
          reg.WriteString('location', ExtractFileDir(FKeyPath));
          WriteTime(DEACT_FOLDER + KeyName);            //Deaktivierungsdatum speichern
          end  //of begin
       else                                             // <= Windows XP
          reg.WriteString('location', FType);

       if not DirectoryExists(PssDir) then              //existiert Dir nicht?
          ForceDirectories(PssDir);                     //dann Dir erstellen

       CreateLnk(FFilePath, BackupLnk);                 //Backup *.lnk erstellen
       DeleteFile(FKeyPath);                            //*.lnk löschen
       FKeyPath := DEACT_FOLDER + KeyName;              //Reg-Pfad aktualisieren
       FRootKey := 'HKLM';
       FEnabled := false;
       result := true;
       end  //of begin
    else
       result := CreateError(Main.Lang.GetString(64), Main.Lang.GetString(76), KeyName);  //Fehlererkennung

  except
    result := false
  end;  //of try

  reg.Free;
end;


function TStartupUserItem.Enable(): Boolean;
var
  Path: string;

begin
  try
    Path := GetKeyValue('HKLM', FKeyPath, 'path');

    if CreateLnk(FFilePath, Path) then                     //Verknüpfung anlegen
       begin
       if not DeleteKey('HKLM', DEACT_FOLDER, AddCircumflex(Path)) then
          result := CreateError(Main.Lang.GetString(63), Main.Lang.GetString(78), FKeyPath)  //Fehlererkennung
       else
          begin
          FKeyPath := Path;                                //aktualisieren
          FRootKey := '';
          FEnabled := true;
          result := true;
          end;  //of if
       end  //of begin
    else
       result := CreateError(Main.Lang.GetString(63), Main.Lang.GetString(79), '');  //Fehlererkennung

  except
    result := false;
  end;  //of try
end;

{ public }
function TStartupUserItem.CreateBackup(): Boolean;
begin
  result := TClearas.CreateLnk(FFilePath, GetBackupLnk);
end;


function TStartupUserItem.Delete(): Boolean;

  function GetKeyName(): string;
  begin   
    result := AddCircumflex(TClearas.GetStartUpDir(Pos('Common', FType) <> 0) + FName);
  end;

begin
  result := true;

  try
    if FEnabled then                           //Schlüssel oder Datei löschen
       begin
       if not DeleteFile(FKeyPath) then        //*.lnk löschen
          result := CreateError(Main.Lang.GetString(65), Main.Lang.GetString(79), FName);  //Fehlererkennung
       end  //of begin
    else
       if not DeleteKey('HKLM', DEACT_FOLDER, GetKeyName()) then
          result := CreateError(Main.Lang.GetString(65), Main.Lang.GetString(77), FKeyPath);  //Fehlererkennung

  except
    result := false;
  end;  //of try
end;


procedure TStartupUserItem.ExportItem(const AFileName: string);
var
  RegFile: TStringList;

begin
  RegFile := TStringList.Create;                  //init Liste/Datei

  try
    RegFile.Append(REG_HEADER);                   //*.reg Header
    RegFile.Append('');
    RegFile.Append(MakeHeadLine());               //REG Schlüssel
    GetRegItem(RegFile);                          //Daten in Liste schreiben
    RegFile.SaveToFile(AFileName {+'.reg'});      //*.REG erstellen

  finally
    RegFile.Free;                                 //freigeben
  end;  //of try
end;


procedure TStartupUserItem.GetItemInfo(var AName, APath: string);
begin
  if FEnabled then
     APath := Main.Lang.GetString(60) +^J+^J+ FKeyPath
  else
     APath := Main.Lang.GetString(61) +^J+^J+ ExpandHKey(FRootKey) +'\'+ FKeyPath;

  AName := Main.Lang.GetString(62) +'"'+ FName +'"';
end;
{ of TStartupUserItem }

{##############################################################################}
{ TStartupList }

constructor TStartupList.Create;
begin
  inherited Create;
  FDeleteBackup := true;
end;

{ private }
function TStartupList.Add(AItem: TStartupListItem): Word;
begin
  result := inherited Add(AItem);
end;


function TStartupList.DelCircumflex(AName: string): string;
begin
  result := StringReplace(AName, '^', '\', [rfReplaceAll]);
end;


function TStartupList.DeleteBackupLnk(): Boolean;               //Backup löschen
begin
  result := DeleteFile(GetBackupLnk());
end;


function TStartupList.GetBackupLnk(): string;
var
  Pss: string;

begin
  if not FItem.Enabled then
     result := TClearas.GetKeyValue('HKLM', FItem.KeyPath, 'backup')
  else
     begin
     Pss := TClearas.GetWinDir +'\pss';

     if not DirectoryExists(Pss) then      //existiert Dir nicht?
        ForceDirectories(Pss);             //dann Dir erstellen

     if (Pos('Common', FItem.TypeOf) <> 0) then
        result := Pss +'\'+ FItem.Name + COMMON_EXT
     else
        result := Pss +'\'+ FItem.Name + USER_EXT;
     end;
end;


function TStartupList.GetItem(AIndex: Word): TStartupListItem;
begin
  result := TStartupListItem(inherited Items[AIndex]);
end;


procedure TStartupList.GetLnkFileNames(AFileList: TStrings; AAllUsers: Boolean);
var
  SR: TSearchRec;
  RootFolder: string;

begin
  RootFolder := TClearas.GetStartUpDir(AAllUsers);   //Ordner von allen Usern oder
                                                     //des angemeldeten Users
  if (FindFirst(RootFolder + '*.lnk', faAnyFile, SR) = 0) then
     try
       repeat
         if (SR.Attr and faDirectory <> faDirectory) then
            AFileList.Add(RootFolder + SR.Name);   //eine Datei wurde gefunden
       until FindNext(SR) <> 0;

     finally
        FindClose(SR);
     end;  //of finally
end;


function TStartupList.GetStartupUserType(const AKeyPath: string): string;
var
  st: string;

begin
  if not TClearas.CheckWindows then                //falls <= WinXP
     result := TClearas.GetKeyValue('HKLM', AKeyPath, 'location')
  else                                             //falls >= Win Vista
     begin
     st := TClearas.GetKeyValue('HKLM', AKeyPath, 'backupExtension');

     if (st = COMMON_EXT) then
        result := COMMON_TYPE
     else
        result := USER_TYPE;
     end;  //of if
end;

{ protected }
function TStartupList.AddItemDisabled(const AKeyPath: string): Integer;
var
  Item: TStartupListItem;

begin   
  Item := TStartupItem.Create(Count, false);          //neues Objekt

  with Item do                                        //Daten übergeben
    begin
    RootKey := 'HKLM';
    KeyPath := AKeyPath;
    Name := ExtractFileName(AKeyPath);
    FilePath := TClearas.GetKeyValue('HKLM', AKeyPath, 'command');
    Time := GetTime();
    TypeOf := TClearas.GetKeyValue('HKLM', AKeyPath, 'hkey');
    end;  //of with

  result := Add(Item);
end;


function TStartupList.AddItemEnabled(const ARootKey, AKeyPath, AName, AFilePath: string): Integer;  //neues Startup-Item
var
  Item: TStartupListItem;

begin
  Item := TStartupItem.Create(Count, true);           //neues Objekt

  with Item do                                        //Daten übergeben
    begin
    RootKey := ARootKey;
    KeyPath := AKeyPath;
    Name := AName;
    FilePath := AFilePath;
    Time := '';

    if (AKeyPath = RUNONCE_KEY) then
       TypeOf := 'RunOnce'
    else
       TypeOf := ARootKey;
    end;  //of with

  Inc(FActCount);
  result := Add(Item);
end;


function TStartupList.AddUserItemDisabled(const AKeyPath: string): Integer;
var
  Item: TStartupListItem;

begin
  Item := TStartupUserItem.Create(Count, false);      //neues Objekt

  with Item do                                        //Daten übergeben
    begin
    RootKey := 'HKLM';
    KeyPath := AKeyPath;
    Name := ExtractFileName(DelCircumflex(AKeyPath));
    FilePath := TClearas.GetKeyValue('HKLM', AKeyPath, 'command');
    Time := GetTime();
    TypeOf := GetStartupUserType(AKeyPath);
    end;  //of with

  result := Add(Item);
end;


function TStartupList.AddUserItemEnabled(const ALnkFile: string; AAllUsers: Boolean): Integer;
var
  Item: TStartupListItem;
  ExeFile: string;

begin
  Item := TStartupUserItem.Create(Count, true);       //neues Objekt

  with Item do                                        //Daten übergeben
    begin
	  RootKey := '';
    ReadLnkFile(ALnkFile, ExeFile);
    KeyPath := ALnkFile;
    FilePath := ExeFile;
    Name := ExtractFileName(ALnkFile);

    if AAllUsers then
       TypeOf := COMMON_TYPE
    else
       TypeOf := USER_TYPE;

    Time := '';
    end;  //of with

  Inc(FActCount);
  result := Add(Item);
end;

{ public }
function TStartupList.CreateBackup(): Boolean;                //Backup erstellen
begin
  result := FItem.CreateBackup();
end;


procedure TStartupList.AddDisabled(const AKeyPath: string);
var
  reg: TRegistry;
  List: TStringList;
  i: Integer;

begin
  List := TStringList.Create;                       //init Liste
  reg := TRegistry.Create(TClearas.SetKeyAccessMode); //init REG-Objekt
  reg.RootKey := HKEY_LOCAL_MACHINE;                //Root Key setzen

  try
    reg.OpenKey(AKeyPath, true);                    //Key öffnen
    reg.GetKeyNames(List);                          //enthaltene Schlüsselnamen auslesen

    for i := 0 to List.Count -1 do
      if (AKeyPath = DEACT_KEY) then                //auslesen + eintragen
         AddItemDisabled(AKeyPath + List[i])
      else
         AddUserItemDisabled(AKeyPath + List[i]);

  finally                                           //freigeben
    reg.Free;
    List.Free;
  end;  //of finally
end;


procedure TStartupList.AddEnabled(const AAllUsers: Boolean);
var
  List: TStringList;
  i: integer;

begin
  List := TStringList.Create;                     //init Liste

  try
    GetLnkFileNames(List, AAllUsers);             //aktivierte Autostart-Programme auslesen

    for i := 0 to List.Count -1 do
      AddUserItemEnabled(List[i], AAllUsers);     //Programm in Liste schreiben

  finally                                         //freigeben
    List.Free;
  end;  //of finally
end;


procedure TStartupList.AddEnabled(const ARootKey, AKeyPath: string);
var
  reg: TRegistry;
  List: TStringList;
  i: Integer;
  FilePath: string;

begin
  List := TStringList.Create;                       //init Liste
  reg := TRegistry.Create(TOSUtils.DenyWOW64Redirection(KEY_ALL_ACCESS));  //init REG-Objekt

  try
    reg.RootKey := TClearas.StrToHKey(ARootKey);    //Root Key setzen
    reg.OpenKey(AKeyPath, true);                    //Key öffnen
    reg.GetValueNames(List);                        //enthaltene Einträge auslesen

    for i := 0 to List.Count -1 do
      begin
      FilePath := reg.ReadString(List[i]);          //Pfad zur *.exe auslesen
      AddItemEnabled(ARootKey, AKeyPath, List[i], FilePath);  //Programm auslesen + eintragen
      end;  //of for

  finally                                           //freigeben
    reg.Free;
    List.Free;
  end;  //of finally
end;


function TStartupList.BackupExists: Boolean;                  //Existiert Backup
begin
  if FItem.StartupUser then
     result := FileExists(GetBackupLnk())
  else
     result := false;
end;


function TStartupList.ChangeItemStatus(): Boolean;
var
  Changed: Boolean;

begin
  try
    Changed := FItem.ChangeStatus;             //Status ändern!

    if Changed then                            //erfolgreich geändert?
       if FItem.Enabled then                   //falls aktiviert...
          begin
          if (FDeleteBackup and FItem.StartupUser) then  //Backup löschen?
             DeleteBackupLnk();

          Inc(FActCount);                      //Programmzähler inkrement
          end  //of begin
       else
          Dec(FActCount);                      //Programmzähler dekrement

    result := Changed;

  except
    result := false;
  end;  //of try
end;


function TStartupList.DeleteItem(): Boolean;
var
  Deleted: Boolean;

begin
  try
    Deleted := FItem.Delete();                 //Item aus REG löschen

    if Deleted then                            //erfolgreich gelöscht?
       if FItem.Enabled then                   //falls aktiviert...
          begin
          if (FDeleteBackup and FItem.StartupUser) then //Backup löschen
             DeleteBackupLnk();

          Dec(FActCount);                      //Programmzähler dekrement
          inherited Remove(FItem);             //Item aus Liste löschen
          FItem := nil;                        //Pointer leeren
          end;  //of begin

    result := Deleted;

  except
    result := false;
  end;  //of try
end;


procedure TStartupList.ExportItem(const AFileName: string; ARegFile: Boolean = true);
begin
  FItem.ExportItem(AFileName);
end;


procedure TStartupList.ExportList(const AFileName: string);
var
  i: Word;
  RegFile: TStringList;
  LastItem, Item: TStartupListItem;

  function MakeHeadLine(ARootKey, AKeyPath: string): string;
  begin
    result := '['+ TClearas.ExpandHKey(ARootKey) +'\'+ AKeyPath +']';
  end;

begin
  RegFile := TStringList.Create;                       //init StringList

  try
    RegFile.Append(REG_HEADER);
    LastItem := nil;

    for i := 0 to Count -1 do                          //Objektliste abarbeiten
      begin
      Item := GetItem(i);                              //Pointer auf aktuelles Item

      if (not Assigned(LastItem) or (Item.RootKey <> LastItem.RootKey) or
         (Item.KeyPath <> LastItem.KeyPath)) then
         begin
         RegFile.Append('');
         RegFile.Append(MakeHeadLine(Item.RootKey, Item.KeyPath));
         end;  //of begin

      Item.GetRegItem(RegFile);                        //Einträge auslesen
      LastItem := Item;                                //aktuellen Pointer sichern
      end;  //of for

    RegFile.SaveToFile(AFileName);                     //Datei speichern

  finally
    RegFile.Free;                                      //freigeben
  end;  //of try                                         
end;


function TStartupList.IndexOf(AName: string): Integer;
var
  i: Integer;

begin
  result := -1;

  for i := 0 to Count -1 do
    if (GetItem(i).Name = AName) then
       begin
       result := i;
       Break;
       end;  //of begin
end;


function TStartupList.IndexOf(AName: string; AEnabled: Boolean): Integer;
var
  i: Integer;

begin
  result := -1;

  for i := 0 to Count -1 do
    if ((GetItem(i).Name = AName) and (GetItem(i).Enabled = AEnabled))then
       begin
       result := i;
       Break;
       end;  //of begin
end;


procedure TStartupList.Insert(AIndex: Integer; AItem: TStartupListItem);
begin
  inherited Insert(AIndex, AItem);
end;


procedure TStartupList.Load(ARunOnce: Boolean);             //Autostart auslesen
begin
  AddEnabled('HKLM', STARTUP_KEY);

  if TClearas.IsWindows64 then                      //bei 64Bit Windows
     AddEnabled('HKLM', STARTUP_KEY64);             //speziellen Autostart-Ordner auslesen

  if ARunOnce then                                  //RunOnce auslesen?
     begin
     AddEnabled('HKLM', RUNONCE_KEY);
     AddEnabled('HKCU', RUNONCE_KEY);
     end;

  AddEnabled('HKCU', STARTUP_KEY);
  AddEnabled(true);
  AddEnabled(false);
  AddDisabled(DEACT_KEY);
  AddDisabled(DEACT_FOLDER);
end;
{ of TStartupList }

{##############################################################################}
{ TContextItem }

function TContextListItem.MakeHeadLine(): string;
begin
  result := '[HKEY_CLASSES_ROOT\'+ GetKeyPath() +']';
end;

{ public }
function TContextListItem.Delete(): Boolean;
begin
  if not DeleteKey('HKCR', ExtractFileDir(KeyPath), FName) then  //Schlüssel löschen
     result := CreateError(Main.Lang.GetString(65), Main.Lang.GetString(77), '')     //Fehlererkennung
  else
     result := true;
end;


procedure TContextListItem.ExportItem(const AFileName: string);
var
  RegFile: TStringList;

begin
  RegFile := TStringList.Create;                  //init Liste/Datei

  try
    GetRegItem(RegFile);                          //Daten in Liste schreiben
    RegFile.SaveToFile(AFileName);                //*.REG erstellen

  finally
    RegFile.Free;                                 //freigeben
  end;  //of finally
end;


procedure TContextListItem.GetItemInfo(var AName, APath: string);
var
  Text: string;

begin
  Text := TClearas.GetKeyValue('HKCR', GetKeyPath(), '');
  APath := Main.Lang.GetString(87) +':'+ ^J+^J +'"'+ Text +'"';
  AName := Main.Lang.GetString(62) +'"'+ FName +'"';
end;


function TContextListItem.GetRegItem(ARegFile: TStrings): Boolean;
var
  reg: TRegistry;
  List: TStringList;

  procedure GetRegData(ARegFile: TStrings);
  var
    i: Integer;

  begin
    ARegFile.Append('');
    ARegFile.Append('[HKEY_CLASSES_ROOT\'+ reg.CurrentPath +']');

    for i := 0 to List.Count -1 do                    //Werte in Liste schreiben
      if (List[i] = '') then
         ARegFile.Append('@='+ AddPathDelimiter(reg.ReadString(List[i])))
      else
         ARegFile.Append('"'+ List[i] +'"='+ AddPathDelimiter(reg.ReadString(List[i])));
  end;

begin
  List := TStringList.Create;
  reg := TRegistry.Create(SetKeyAccessMode);          //init reg Objekt

  try
    reg.RootKey := HKEY_CLASSES_ROOT;                 //RootKey setzen
    reg.OpenKey(KeyPath, false);                      //Key öffnen
    reg.GetValueNames(List);                          //alle Werte lesen

    ARegFile.Append(REG_HEADER);
    GetRegData(ARegFile);                             //Werte in Liste schreiben

    if (FType = 'Shell') then
       begin
       List.Clear;
       reg.CloseKey;
       reg.OpenKey(KeyPath +'\command', false);      //Key öffnen
       reg.GetValueNames(List);                       //alle Werte lesen
       GetRegData(ARegFile);                          //Werte in Liste schreiben
       end;  //of begin

    result := true;

  finally                                             //freigeben
    List.Free;
    reg.Free;
  end;  //of finally
end;
{ of TContextItem }

{##############################################################################}
{ TShellItem }

function TShellItem.GetKeyPath(): string;
begin
  result := FLocation +'\'+ FType +'\'+ FName;
end;

{ protected }
function TShellItem.Disable(): Boolean;
begin
  try
    WriteStrValue('HKCR', KeyPath, 'LegacyDisable', '');
    FEnabled := false;
    result := true;

  except
    result := false;
  end;  //try
end;


function TShellItem.Enable(): Boolean;
begin
  try
    if not DeleteValue('HKCR', KeyPath, 'LegacyDisable') then
       result := CreateError(Main.Lang.GetString(65), Main.Lang.GetString(75), '')
    else
       result := true;

    FEnabled := true;

  except
    result := false;
  end;  //try
end;
{ of TShellItem }

{##############################################################################}
{ TShellExItem }

function TShellExItem.GetKeyPath(): string;
begin
  result := FLocation + CONTEXTMENU_KEY +'\'+ FName;
end;

{ protected }
function TShellExItem.Disable(): Boolean;
var
  OldValue: string;

begin
  try
    OldValue := GetKeyValue('HKCR', KeyPath, '');
    WriteStrValue('HKCR', KeyPath, '', '-' + OldValue);
    FEnabled := false;
    result := true;

  except
    result := false;
  end;  //try
end;


function TShellExItem.Enable(): Boolean;
var
  OldValue, NewValue: string;

begin
  try
    OldValue := GetKeyValue('HKCR', KeyPath, '');
    NewValue := Copy(OldValue, 2, Length(OldValue));
    WriteStrValue('HKCR', KeyPath, '', NewValue);
    FEnabled := true;
    result := true;

  except
    result := false;
  end;  //try
end;
{ of TShellExItem }

{##############################################################################}
{ TContextList }

constructor TContextList.Create;
begin
  inherited Create;
  FActCount := 0;
end;

{ private }
function TContextList.Add(AItem: TContextListItem): Word;
begin
  result := inherited Add(AItem);
end;


function TContextList.FindDouble(AName, AKeyName: string): Boolean;
begin
  result := false;

  if (Count > 0) then
     if (IndexOf(AName) <> -1) then
        result := GetItem(IndexOf(AName)).TypeOf = AKeyName;
end;


function TContextList.GetItem(AIndex: Word): TContextListItem;
begin
  result := TContextListItem(inherited Items[AIndex]);
end;

{ protected }
function TContextList.AddShellItem(const AName, ALocation: string; AEnabled: Boolean): Word;
var
  Item: TContextListItem;

begin
  Item := TShellItem.Create(Count, AEnabled);   //neues Item

  with Item do                                  //Daten übergeben
    begin
    FName := AName;
    FLocation := ALocation;
    FType := 'Shell';

    if AEnabled then
       Inc(FActCount);                          //Zähler inkrement
    end;  //of with

  result := Add(Item);
end;


function TContextList.AddShellExItem(const AName, ALocation: string; AEnabled: Boolean): Word;  //neues Context-Item
var
  Item: TContextListItem;

begin
  Item := TShellExItem.Create(Count, AEnabled); //neues Item

  with Item do                                  //Daten übergeben
    begin
    FName := AName;
    FLocation := ALocation;
    FType := 'ShellEx';

    if AEnabled then
       Inc(FActCount);                          //Zähler inkrement
    end;  //of with

  result := Add(Item);
end;


procedure TContextList.AddEntry(const AKeyName: string; AShell: Boolean);
var
  reg: TRegistry;
  i: Integer;
  List: TStringList;
  Key: string;
  Enabled: Boolean;

begin
  reg := TRegistry.Create(TClearas.SetKeyAccessMode);     //init REG-Objekt
  List := TStringList.Create;                             //init Liste

  if AShell then
     Key := AKeyName +'\shell'
  else
     Key := AKeyName + CONTEXTMENU_KEY;

  try
    reg.RootKey := HKEY_CLASSES_ROOT;                     //Root Key setzen
    reg.OpenKey(Key, false);                              //Key öffnen
    reg.GetKeyNames(List);                                //alle Einträge im Key auslesen

    for i := 0 to List.Count -1 do
      begin
      reg.CloseKey;
      reg.OpenKey(Key +'\'+ List[i], false);

      if ((reg.ReadString('') <> '') and (List[i][1] <> '{') and
         (reg.ReadString('')[1] <> '@') and not FindDouble(List[i], AKeyName)) then  //wichtige, leere und doppelte Einträge filtern!
         begin
         if AShell then                                   //nach "Shell" suchen
            begin
            Enabled := not reg.ValueExists('LegacyDisable');  //Status
            AddShellItem(List[i], AKeyName, Enabled);     //neues Item in Liste
            end  //of begin
         else                                             //sonst nach "ShellEx" suchen
            begin
            Enabled := reg.ReadString('')[1] <> '-';      //Status
            AddShellExItem(List[i], AKeyName, Enabled);   //neues Item in Liste
            end  //of begin
         end;  //of begin
      end;  //of for

  finally                                                 //freigeben
    List.Free;
    reg.Free;
  end;  //of finally
end;

{ public }
procedure TContextList.AddEntry();
var
  reg: TRegistry;
  i, j, k: integer;
  Hkcr, Temp, Shellex: TStringList;

begin
  reg := TRegistry.Create(KEY_READ);             //init REG-Object
  Hkcr := TStringList.Create;                    //init Liste HKCR
  Temp := TStringList.Create;                    //init Liste zum Suchen
  Shellex := TStringList.Create;                 //init Liste ShellEx

  try
    reg.RootKey := HKEY_CLASSES_ROOT;            //Root Key setzen

    if not reg.KeyExists('$$$_auto_file') then   //falls "Dummy Eintrag" nicht existiert...
       reg.CreateKey('$$$_auto_file');           //erstellen, um Bug zu vermeiden

    reg.OpenKey('', false);                      //Key öffnen
    reg.GetKeyNames(Hkcr);                       //alle Einträge im Key auslesen
    FCountMax := Hkcr.Count;                     //Max auf Anzahl der Schlüssel
    FWorkCountMax(Self, FCountMax);              //"Beginn der Suche" melden
    FProgress := 0;                              //Progress-Bar Status-Reset

    for i := 0 to Hkcr.Count -1 do
      begin
      Inc(FProgress);                            //Progress-Zähler
      FWorkCount(Self, FProgress);               //Progress anzeigen

      reg.CloseKey;
      reg.OpenKey(Hkcr[i], false);               //Key öffnen

      if reg.HasSubKeys then                     //existiert Unterschlüssel?
         begin
         Temp.Clear;
         reg.GetKeyNames(Temp);

         for j := 0 to Temp.Count -1 do
           if ((Temp[j] = 'shellex') or (Temp[j] = 'ShellEx')) then
              begin
              reg.CloseKey;
              reg.OpenKey(Hkcr[i] +'\'+ Temp[j], false); //Key öffnen

              if reg.HasSubKeys then             //existiert Unterschlüssel?
                 begin
                 Shellex.Clear;
                 reg.GetKeyNames(Shellex);

                 for k := 0 to Shellex.Count -1 do
                   if (Shellex[k] = 'ContextMenuHandlers') then
                      begin
                      reg.CloseKey;
                      reg.OpenKey(Hkcr[i] +'\'+ Temp[j] +'\'+ Shellex[k], false);

                      if reg.HasSubKeys then     //existiert Unterschlüssel...
                         AddEntry(Hkcr[i]);      //dann Eintrag gefunden und hinzufügen
                      end;  //of for
                 end;  //of begin
              end;  //of for
         end;  //of begin
      end;  //of for

  finally                                        //freigeben
    Temp.Free;
    Hkcr.Free;
    Shellex.Free;
    reg.Free;
    FContextCount(Self);                         //"Ende der Suche" melden
  end;  //of finally
end;


procedure TContextList.AddEntry(const AKeyName: string);
begin
  AddEntry(AKeyName, true);
  AddEntry(AKeyName, false);
end;


function TContextList.ChangeItemStatus(): Boolean;
var
  Changed: Boolean;

begin
  try
    Changed := FItem.ChangeStatus;             //Status ändern!

    if Changed then                            //erfolgreich geändert?
       if FItem.Enabled then                   //falls aktiviert...
          Inc(FActCount)                       //Programmzähler inkrement
       else
          Dec(FActCount);                      //Programmzähler dekrement

    result := Changed;

  except
    result := false;
  end;  //of try
end;


function TContextList.DeleteItem(): Boolean;
var
  Deleted: Boolean;

begin
  try
    Deleted := FItem.Delete();                 //Item aus REG löschen

    if Deleted then                            //erfolgreich gelöscht?
       begin
       if FItem.Enabled then                   //falls aktiviert...
          Dec(FActCount);                      //Programmzähler dekrement

       inherited Remove(FItem);                //Item aus Liste löschen
       FItem := nil;                           //Pointer leeren
       end;  //of begin

    result := Deleted;

  except
    result := false;
  end;  //of try
end;


procedure TContextList.ExportItem(const AFileName: string);
begin
  FItem.ExportItem(AFileName);
end;


function TContextList.IndexOf(AName: string): Integer;
var
  i: Integer;

begin
  result := -1;

  for i := 0 to Count -1 do
    if (GetItem(i).Name = AName) then
       begin
       result := i;
       Break;
       end;  //of begin
end;


function TContextList.IndexOf(AName, ALocation: string): Integer;
var
  i: Integer;

begin
  result := -1;

  for i := 0 to Count -1 do
    if ((GetItem(i).Name = AName) and (GetItem(i).Location = ALocation)) then
       begin
       result := i;
       Break;
       end;  //of begin
end;


procedure TContextList.Insert(AIndex: Integer; AItem: TContextListItem);
begin
  inherited Insert(AIndex, AItem);
end;


procedure TContextList.Load;
begin
  AddEntry('AllFilesystemObjects');
  AddEntry('Directory');
  AddEntry('Folder');
  AddEntry('Drive');
end;
{ of TContextList }

end.
